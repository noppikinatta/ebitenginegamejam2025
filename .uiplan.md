# UI Package Implementation Plan

## 概要
Ebitengine Game Jam 2025向けストラテジーゲームのUIパッケージ実装計画
解像度: 640x360（固定）

## 実装方針
- テストコードは書かない（UIは実際の動作確認で検証）
- scene.InGameで各UIを組み合わせて動作確認
- ハードコーディングも許容（Game Jam向け）
- 段階的に実装し、都度動作確認

## 実装フェーズ

### Phase 1: 基盤実装
#### 1.1 Widgetインタフェース
- [x] `ui/widget.go` にWidgetインタフェースを定義
- [x] 基本的な描画ヘルパー関数を追加

#### 1.2 共通描画機能
- [x] 資源量描画関数（60x20領域）
  - 左20x20に資源アイコン、右40x20に数値表示
- [x] カード描画関数（40x60領域）
  - 基本的な矩形描画（後でイラストに差し替え）
- [x] ボタン描画関数
  - クリック判定付きボタン

### Phase 2: 基本Widget実装
#### 2.1 ResourceView
- [x] `ui/resource.go` を実装
  - 位置: (0,0,300,20)
  - 5種類の資源を60x20ずつで表示
  - 在庫と増分を「10(+2)」形式で表示
  - coreパッケージのTreasuryから情報取得

#### 2.2 CalendarView
- [x] `ui/calendar.go` を実装
  - 位置: (520,0,120,20)
  - Turn.YearMonth()の結果を「YYYY/MM」形式で表示
  - coreパッケージのTurnから情報取得

### Phase 3: MainViewコンテナ
#### 3.1 MainView基盤
- [ ] `ui/mainview.go` を実装
  - 位置: (0,20,520,280)
  - 内部でMapGridView, MarketView, BattleView, TerritoryViewを切り替え
  - 初期表示はMapGridView
  - 現在表示中のViewを管理

#### 3.2 MapGridView
- [ ] `ui/mapgrid.go` を実装
  - 5x5のPoint配置（固定）
  - 520x280を5x5に分割（104x56セル）
  - 各セルの中央に24x24のPoint画像
  - Point名をPoint画像の下に描画（fontSize=12）
  - MyNationから到達可能なPointに線を描画
  - Pointクリック処理
    - MyNationPoint/OtherNationPoint → MarketView
    - WildernessPoint（未制圧） → BattleView
    - WildernessPoint（制圧済み） → TerritoryView
    - BossPoint → BattleView

### Phase 4: MarketView実装
#### 4.1 MarketView
- [ ] `ui/market.go` を実装
  - ヘッダ: (0,20,480,40) - Nation名表示
  - 戻るボタン: (480,20,40,40) - [x]ボタン
  - CardPack表示領域: 260x80 × 6個
    - (0,60,260,80), (260,60,260,80), (0,140,260,80), ...
  - 各CardPackの詳細表示
    - 画像: 24x32
    - 名前: CardPack名
    - 説明: CardPackの説明
    - 値段: Resource画像と数値の組み合わせ
    - 購入可能性判定（資源不足時は赤文字）
  - CardPackクリック時の購入処理

### Phase 5: BattleView実装
#### 5.1 BattleView
- [ ] `ui/battle.go` を実装
  - ヘッダ: (0,20,520,40) - "Battle of $POINT_NAME"
  - 戻るボタン: (480,20,40,40) - [x]ボタン
  - 敵画像: (180,60,160,160) - クリックで勝利処理
  - BattleCard置き場: (0,220,480,60) - 40x60 × 12枚
  - Power表示: (480,220,40,60) - 計算されたPower値
  - CardDeckViewとの連携
    - CardDeckからカードを受け取り
    - クリックでカードをCardDeckに戻す

### Phase 6: TerritoryView実装
#### 6.1 TerritoryView
- [ ] `ui/territory.go` を実装
  - ヘッダ: (0,20,520,40) - Point名
  - 戻るボタン: (480,20,40,40) - [x]ボタン
  - 産出量表示: (0,60,60,100) - 60x20 × 5種類の資源
  - StructureCard置き場: (0,160,520,60)
  - 効果説明: (60,60,460,100) - 配置したカードの効果
  - CardDeckViewとの連携

### Phase 7: InfoView実装
#### 7.1 InfoView基盤
- [ ] `ui/info.go` を実装
  - 位置: (520,20,120,280)
  - 状況に応じた情報表示の切り替え
  - マウスカーソル位置判定ロジック

#### 7.2 各情報表示モード
- [ ] HistoryView実装
  - 120x20 × 14行でイベント履歴表示
  - デフォルト表示
- [ ] CardInfoView実装
  - カード名、イラスト、種類、詳細情報表示
  - BattleCard/StructureCardで表示内容切り替え
- [ ] NationPointView実装
  - Point名とCardPack一覧表示
- [ ] WildernessPointView実装
  - Enemy情報、Yields、StructureCard情報表示
- [ ] EnemySkillView実装
  - Enemyスキルの名前と説明表示

### Phase 8: CardDeckView実装
#### 8.1 CardDeckView
- [ ] `ui/carddeck.go` を実装
  - 位置: (0,300,640,60)
  - 40x60 × 16枚のカード表示
  - MainViewの状態に応じたフィルタリング
    - BattleView表示時: BattleCardのみ
    - TerritoryView表示時: StructureCardのみ
    - その他: 全カード表示
  - カードクリック処理
    - BattleView時: BattlefieldにBattleCard追加
    - TerritoryView時: TerritoryにStructureCard追加

### Phase 9: 統合・調整
#### 9.1 Widget間連携
- [ ] MainViewとInfoViewの連携
  - マウスカーソル位置による情報表示切り替え
- [ ] CardDeckViewと各Viewの連携
  - カードの移動処理
- [ ] 全体的なマウスイベント処理

#### 9.2 最終調整
- [ ] レイアウト微調整
- [ ] ダミーテキスト・画像の置き換え
- [ ] scene.InGameでの統合動作確認

## 実装時の注意点

### レイアウト座標
- 全て設計書通りの固定座標を使用
- 640x360解像度に最適化

### 描画順序
1. ResourceView, CalendarView
2. MainView（内部でMapGrid/Market/Battle/TerritoryView）
3. InfoView
4. CardDeckView

### coreパッケージとの連携
- UI操作時にcoreパッケージのオブジェクト状態を変更
- 必要に応じてcoreパッケージにスタブメソッド追加

### 動作確認方法
- 各Phase完了時に`scene.InGame`で実際の動作確認
- `go run`での実行確認は人間が行う

### Game Jam向け最適化
- 完璧なコードよりも動くコードを優先
- ハードコーディングも許容
- 基本機能から順次実装し、時間に応じて詳細機能を追加

## 将来的なターン経過処理の改善

### ResourceView.SetIncrementの呼び出しタイミング

ResourceViewの増分表示（「10(+2)」の+2部分）は、次のターンで得られる収入を事前に表示するためのもの。

**現在の課題**
- `GameState.AddYield()`は計算とTreasury更新を同時に行う
- UI側で次ターンの収入予測ができない

**提案する改善**
1. `GameState`に`CalculateYield() ResourceQuantity`メソッドを追加
   - `AddYield()`の計算部分のみを分離
   - MyNation.BasicYield + 制圧済みTerritoryのYieldを計算して返す
2. UI側での呼び出し
   ```go
   increment := gameState.CalculateYield()
   resourceView.SetIncrement(increment)
   ```
3. `AddYield()`は`CalculateYield()`を使って実装
   ```go
   func (gs *GameState) AddYield() {
       totalYield := gs.CalculateYield()
       gs.Treasury.Add(totalYield)
   }
   ```

**実装タイミング**
- Phase 3でMainViewを実装する際
- GameStateとResourceViewの連携時に追加
- scene.InGameでの統合時に呼び出し処理を実装

**メモ**
- 増分表示により、プレイヤーが次ターンの収入を予測できる
- ターン経過前の戦略立案に有用
- StructureCard配置による収入変化の確認にも使用可能

### 実装方針：暫定的なscene.InGame実装

**Game Jam向け段階的実装**
1. **Phase 1: scene.InGameで暫定実装**
   ```go
   // scene.InGameに直接実装（暫定）
   func (g *InGame) Update() error {
       increment := g.gameState.CalculateYield()
       g.resourceView.SetIncrement(increment)
       return nil
   }
   ```

2. **Phase 2: 後日リファクタリング**
   - GameStateとUIを仲介するControllerやServiceクラスを作成
   - DI（Dependency Injection）パターンの導入
   - scene.InGameからビジネスロジックを分離

**暫定実装の理由**
- scene.InGameには本来ゲーム進行制御以外のロジックは書くべきではない
- しかし、適切なDI設計には時間がかかる
- Game Jam期間中は動作優先、設計は後で改善

**リファクタリング計画**
- UIController/GameControllerクラスの導入
- GameStateとUI間の責任分離
- テスト可能な設計への移行
