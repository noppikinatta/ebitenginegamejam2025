# 要件定義書

## 概要

この機能は、Goベースのゲームプロジェクトのcoreパッケージの包括的な再設計とリファクタリングを行います。再設計の目的は、カプセル化の改善、抽象化の簡素化、複数カードインスタンスのサポート、および適切なアーキテクチャレイヤー（viewmodelとflowパッケージ）の確立による関心の分離の改善です。

## 要件

### 要件1

**ユーザーストーリー:** 開発者として、同じカードタイプの複数インスタンスを許可したい。これにより、プレイヤーがデッキ内で重複カードを収集・使用できるようになる。

#### 受け入れ基準

1. プレイヤーが同じカードを複数回取得した場合、システムは経験値を増加させるのではなく複数のインスタンスを保存する
2. カードを表示する場合、システムは重複カードの枚数を表示する
3. バトルでカードを使用する場合、システムは同じカードタイプの複数インスタンスからの選択を許可する

### 要件2

**ユーザーストーリー:** 開発者として、coreパッケージのカプセル化を改善したい。これにより、内部状態が適切に保護され、明確に定義されたインターフェースを通じてアクセスされるようになる。

#### 受け入れ基準

1. 他のパッケージからcoreパッケージの型にアクセスする場合、システムは必要な公開メソッドのみを公開する
2. coreパッケージのインスタンスを作成する場合、システムはコンストラクタ関数（New+型名パターン）を使用する
3. 内部状態を変更する場合、システムは外部パッケージからの直接フィールドアクセスを防ぐ

### 要件3

**ユーザーストーリー:** 開発者として、CardDeckの実装を簡素化したい。これにより、CardIDによるカード枚数管理のみに焦点を当てることができる。

#### 受け入れ基準

1. デッキ内のカードを管理する場合、システムはCardIDと枚数のマッピングのみを保存する
2. カードを追加する場合、システムはAdd(CardID)メソッドを提供する
3. カードを削除する場合、システムは成功ステータスを返すRemove(CardID) boolメソッドを提供する
4. カード枚数を照会する場合、システムはCount(CardID) intメソッドを提供する

### 要件4

**ユーザーストーリー:** 開発者として、BattleCardからExperience概念を削除したい。これにより、カードの進歩が数量ベースの収集に簡素化される。

#### 受け入れ基準

1. BattleCardが作成される場合、システムは経験値フィールドを含まない
2. 同じカードが複数取得される場合、システムは経験値ではなくカード枚数を増加させる
3. バトルカードを表示する場合、システムは経験値レベルではなくカード枚数を表示する

### 要件5

**ユーザーストーリー:** 開発者として、BattleCardを不変にしたい。これにより、ゲーム全体を通じてカードデータの整合性が維持される。

#### 受け入れ基準

1. BattleCardが作成される場合、システムはそのプロパティの変更を許可しない
2. BattleCardのプロパティにアクセスする場合、システムは公開フィールドではなくgetterメソッドを提供する
3. カードデータが必要な場合、システムは変更を防ぐためにコピーまたは読み取り専用アクセスを返す

### 要件6

**ユーザーストーリー:** 開発者として、core型から表示関連フィールドを削除したい。これにより、コアロジックがプレゼンテーション関心事から分離される。

#### 受け入れ基準

1. BattleCardSkillを定義する場合、システムはDescriptionKeyフィールドを含まない
2. StructureCardを定義する場合、システムはDescriptionKeyフィールドを含まない
3. Enemyを定義する場合、システムはQuestionフィールドを含まない
4. core型が使用される場合、システムはゲームロジックデータのみに焦点を当てる

### 要件7

**ユーザーストーリー:** 開発者として、TerritoryとTerrainを再構築したい。これにより、可変な建設計画と不変な地形プロパティの間でテリトリーデータが適切に分離される。

#### 受け入れ基準

1. Territoryを定義する場合、システムは地形参照とカードリストを含む
2. Terrainを定義する場合、システムはbaseYieldとcardSlotプロパティを持つ不変型とする
3. 建設を計画する場合、システムは別のConstructionPlan型を使用する
4. 建設計画をコミットする場合、システムはメモリ共有なしでカードデータをTerritoryにコピーする

### 要件8

**ユーザーストーリー:** 開発者として、Point型システムを改善したい。これにより、UIコードでの直接型キャストなしに異なるポイント型を処理できるようになる。

#### 受け入れ基準

1. Pointインターフェースを定義する場合、システムは列挙値を返すPointType()メソッドを含む
2. ポイントを変換する場合、システムはAsBattlePoint()、AsTerritoryPoint()、AsMarketPoint()メソッドを提供する
3. UIがポイント固有データを必要とする場合、システムは直接キャストではなく変換メソッドを使用する
4. ポイント型が不明な場合、システムはブール戻り値で適切に処理する

### 要件9

**ユーザーストーリー:** 開発者として、viewmodelパッケージを確立したい。これにより、UIコンポーネントが直接coreパッケージ依存なしにクリーンなデータアクセスを持てるようになる。

#### 受け入れ基準

1. UIがデータを必要とする場合、システムは適切なメソッドを持つviewmodel型を提供する
2. バトル情報を表示する場合、システムは敵とカードデータを持つBattleViewModelを使用する
3. マーケットデータを表示する場合、システムはアイテムと価格情報を持つMarketViewModelを使用する
4. テリトリー情報をレンダリングする場合、システムは収穫量とカードデータを持つTerritoryViewModelを使用する

### 要件10

**ユーザーストーリー:** 開発者として、ユースケース操作のためのflowパッケージを作成したい。これにより、UI相互作用が適切なユースケースレイヤーを通じて処理される。

#### 受け入れ基準

1. UIがアクションを実行する場合、システムはflowパッケージメソッドを使用する
2. バトルアクションが発生する場合、システムはカード削除と征服にBattleFlowを使用する
3. マーケット購入が発生する場合、システムは取引処理にMarketFlowを使用する
4. テリトリー建設が発生する場合、システムは計画管理にTerritoryFlowを使用する

### 要件11

**ユーザーストーリー:** 開発者として、Marketシステムを強化したい。これにより、マーケットアイテムがレベル効果とリソース取引機能を持てるようになる。

#### 受け入れ基準

1. MarketItemを定義する場合、システムはマーケットレベル変更のためのLevelEffectフィールドを含む
2. アイテムを購入する場合、システムは自動的にマーケットにレベル効果を適用する
3. MarketItemが投資を表す場合、システムはnil CardPackを許可する
4. リソース取引が必要な場合、システムはMarketItemでResourceQuantityフィールドをサポートする